            ＝ TOPPERS/JSPカーネル ユーザズマニュアル ＝
                         （M32C ターゲット依存部）

            （Release 1.4.4 対応，最終更新: 20-May-2011）

------------------------------------------------------------------------ 
 TOPPERS/JSP Kernel

     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN
 Copyright (C) 2003-2004, 2010, 2011 by Naoki Saito
            Nagoya Municipal Industrial Research Institute, JAPAN
 Copyright (C) 2003-2004 by Platform Development Center
                                         RIOCH COMPANY,LTD. JAPAN

 上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
 によって公表されている GNU General Public License の Version 2 に記
 述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
 を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
 利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
 含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
 接的または間接的に生じたいかなる損害に関しても，その責任を負わない．

------------------------------------------------------------------------

1.  M32C ターゲット依存部の概要

1.1  ターゲットシステムと開発環境

　M32C プロセッサのターゲット依存部は，ターゲットシステムとして
オークス電子株式会社の OAKS32 をサポートしている．
OAKS32 は プロセッサとして M30833FJFP(100pin版) または M30835FJGP(144pin版)
を搭載している．

1.2 開発環境と実行環境

開発環境は，ルネサスエレクトロニクス社製の開発環境を使用する．

実行環境は Windows がインストールされており，かつ，シリアルポートを
搭載した PC があれば，ロードモジュールの構築，ボードへの転送，
およびボード上での実行が可能である．

1.3  サポートする機能の概要

ターゲット依存とされている機能に対するサポート状況は以下の通り．
	・性能評価用システム時刻参照機能 (vxget_tim) ： サポート
	・割込みマスクの変更・参照 (chg_ixx， get_ixx)：未サポート
	・割り込みの禁止と許可(dis_int，ena_int)：未サポート

1.4  他のターゲットへのポーティング

M32CはCPU上に多くのデバイスが実装されており，SFRという形式で
統一化されている．そのため M32C シリーズの CPU を搭載するボードであれば，
ポーティングは容易に出来ると思われる．

1.5  シリアルポート

ターゲットボードには UART1 が実装されており，また UART0 ポートが
拡張可能となっている．UART1 は，デバッガ KD3083 を用いたデバッグ用の
ポートとして使用することを想定している.

シリアルドライバは UART0 ポートへの対応が行われており，アプリケーション用
として利用可能となっている．

UART0 ポートの設定を以下に示す．
	・ボーレート，38400[bps]
	・データ長，8 ビット
	・ストップビット，1 ビット
	・パリティなし

1.6  対象とするソースコードの文字コード

TOPPERSプロジェクトから公開される TOPPERS/JSP カーネルのパッケージは，
文字コード及び改行コードが EUC+LF 及び SJIS+CRLF の 2つのパターンの
パッケージが存在する．EUC+LF版のパッケージでもダウンロードして展開後，
文字コード変換すれば使用可能と思われるが，M32C依存部を利用する場合は，
SJIS+CRLF のパッケージをダウンロードすることを推奨する．


2.  M32C プロセッサ依存部の機能

この節では，カーネルおよびシステムサービスの機能の中で，M32C依存の部分
について解説する．

2.1  データ型

・整数型
	・int 型と unsigned int 型のサイズは 16ビットである．
	・_int64_ には対応していない．

・ポインタ型
	VP および VP_INT は共に far ポインタと定義している．

(説明)
ポインタに関して，M32C では16ビット長の near ポインタと32ビット長の
far ポインタが存在する．near ポインタは RAM 及びデバイスのポート領域である
SFR(Special Function Register) をアクセスする為のポインタである．
一方，far ポインタは near ポインタでアクセス可能な領域に加え
ROM 領域までアクセスが可能なポインタである．

ポインタ変数に対し明示的に near も far も指定しない場合，
コンパイラ(NC308)はポインタ変数を far ポインタとして扱う．
そのため，通常の使用ではポインタのサイズを特に意識する必要はないが，
near と far を明示的に指定して同時に使う場合，代入などでアドレス情報が
欠落することがないか注意する必要がある．

2.2  割込み管理機能と割込みハンドラ

DEF_INHで指定する割込みハンドラ番号（inhno）は，M32Cでのソフトウェア割込み
番号を表し，そのデータ型（INHNO）は char型に定義されている．
DEF_INHで，例外ベクタ番号として有効でない値や，外部割込みに対応しない
番号を指定した場合の動作は保証されない．

ハードウェア割込みは割込み禁止とすることができる．M32Cの割込みの禁止は
フラグレジスタ中の割込み許可フラグ(Iフラグ)によって行う．すなわち，Iフ
ラグが０の場合はマスカブル割込みは禁止され１の場合は許可される．

割込みベクタは設定位置に静的に配置される．本開発環境ではコンフィギュ
レーションから生成される kernel_cfg.c の内容を識別し，自動的に静的な
割込みベクタ定義ファイルを生成するユーティリティを用意している． この
ユーティリティは前処理された kernel_cfg.c の内容を utils/m16c-renesas
ディレクトリ中の m16cvec.exe コマンドで解析し，割込みベクタ定義ファイル
m16cvec.inc を生成する．m16cvec.inc はCPUのスタートアップモジュールである
start.a30 からインクルードされ，割込みベクタをROM上に静的に配置する．

2.3  CPU 例外管理機能と CPU 例外ハンドラ

  CPU例外として，ハードウェアノンマスカブル割込みとソフトウェアノンマスカ
ブル割込みがある．ハードウェアノンマスカブル割込み中のリセットを除いて
ベクトルの設定が可能である．
  CPU例外ベクタは割込みハンドラと同様に設定位置に静的に配置される．
CPU例外ハンドラに関しても割込みハンドラと同様に m16cvec.exe を用いて，
CPU例外ベクタ定義を自動的に生成することができる．このデータは割込み
ハンドラと同様にm16cvec.incに設定される．

　DEF_EXC で指定するCPU例外ハンドラ番号（excno）は，M32Cでのソフトウエア
割込み番号を表し，そのデータ型（EXCNO）は char型に定義されている．

2.4  スタートアップモジュール

m32c依存のスタートアップモジュール (start.a30) は次に示す初期化を実行
した後，カーネル (kernel_start) を起動する．ただし， kernel_start から
戻ってくることは想定していない．

(1) スタックポインタの設定

(2) CPU関連の初期設定

プロセッサモードの設定とクロックの設定を行う．

(3) hardware_init_hook の呼出し(未実行)

M32Cアセンブラでは，hardware_init_hook の判定ができないことと，
M32Cのハードウェア設定を sys_initialize() 関数の中で行っても
十分に対応できると考えられることから，対応していない.

(4) bssセクションと dataセクションの初期化

bssセクションをゼロクリアする．また，dataセクションを初期化する．

(5) software_init_hook の呼出し

software_init_hookが 0でなければ，software_init_hook を呼出す．
software_init_hook はカーネル起動前に，ソフトウェア環境 (ライブラリ等) 
依存の初期化を行うために用意されている．

software_init_hook の定義は cpu_config.c 中で行う．規定では 0 に仮設定
されている．独自に別の場所で software_init_hook を定義する場合，マクロ
として EXTERNAL_SOFT_HOOK を定義する．そのようにすれば，元の変数定義は
含まれなくなるため，外部からの設定が可能となる．
例えば，ライブラリの初期設定などを行いたい場合は，外部からの変数定義を
行うことが可能となる．

(6) カーネルの起動

kernel_start へ分岐し，カーネルを起動する．kernel_start からリターンし
てくることは想定していない．

2.5  割込み発生時のスタック使用量について

カーネル起動，及び，割込み発生時はタスク用のスタックとは別の割込み専用の
スタックを使用している．このスタック領域は RAMEND というマクロで
指定されたアドレスから低位方向に向かうメモリ上の領域に確保される．
そのため，システム起動時にはこの領域を確保する必要がある．

割込みネストレベルが 0（つまり，タスク実行中）で割込みが発生すると，
カーネルはタスクコンテキスト用スタックにレジスタを保存した後，
割込み用スタックにスタックを切り替える．そのため，タスクコンテキスト用
スタックには，汎用レジスタ，フラグ，PC など 30 バイトの領域が余分に必要となる．

割込みネストレベルが 1以上の状態（つまり，非タスクコンテキスト）で
割込み要求が受け付けられた場合，割込みスタックにレジスタが保存される．
これには割込み発生毎に30バイトずつ必要である．それに加え，それぞれの
割込み処理ルーチンで使用されるスタックサイズが必要となる．

3.  システム依存部の機能

3.1  システムクロックドライバ

システムクロックドライバが isig_tim を呼び出す周期は，sys_defs.h 中の
TIC_NUME と TIC_DENO で定義されている（標準は 1ミリ秒周期）．
この定義を変更することで，isig_timを呼び出す周期を変更することができる．
ただし，タイマの精度が1μ秒であるため，1μ秒単位で端数になる値を設定した
場合には，isig_timの呼出し周期に誤差が生じることになる．

3.2  性能評価用システム時刻参照機能

M32Cでは，性能評価用システム時刻参照機能 (vxget_tim) をサポートしている．
OAKS16では精度 0.0333[us]である．SYSUTIM型は UW 型 (32 ビット符号なし
整数型) である．

3.3  シリアルインタフェースドライバ

OAKS32 では UART0 と UART1 の２つのシリアルポートが利用可能である．
シリアルインタフェースドライバでは UART0 のみに対応し，ログ出力用に
使用している．
一方，UART1 は デバッガ KD3083 でホストPCとの通信用ポートとして使用する
ことを想定している．そのため，そのままではドライバで使用できない.

3.4  メモリマップ

3.4.1  OAKS32のメモリマップ

(1)  実行環境

     0x000000 - 0x0003ff  SFR領域
     0x000400 - 0x0077ff  内臓 RAM，data_NE，data_NO，bss_NE，bss_NO
     0x007800 - 0x007fff  内臓 RAM，デバッグモニタ用RAM領域（モニタが使用※）

     0xf80000 - 0x0ffdff  内蔵 ROM，program，rom_FE，rom_FO，data_NEI，data_NOI
     0xffbd00 - 0xffbdff  内蔵 ROM，ハード，ソフト割込みベクタ領域 (vvector)
     0xffbe00 - 0xfffdff  内蔵 ROM，デバッグモニタプログラム領域※
     0xfffe00 - 0xffffdb  内蔵 ROM，スペシャルページベクタテーブル領域
     0xffffdc - 0xffffff  内蔵 ROM，ハードCPU例外ベクタ領域(fvector)

     注※  デバッガKD3083を使用しない場合は通常のメモリとして使用可能

4.  開発

4.1  開発環境

開発環境は，Windows XP (Service Pack3) で動作確認した．
構築環境はルネサスエレクトロニクス社製の開発環境を用いる．
ビルド管理方法として，以下の 2 つの方法がある．

(1)  ルネサスエレクトロニクス社製の統合開発環境 TM を使用する．

     対象：OAKS32ボード
     方式：ルネサスエレクトロニクス社の TM を用いて構築する
           その際，カーネル部をライブラリ化せず構築する
     動作確認ツール：
			NC308WA V.5.42 Release 00 無償評価版
			TM V3.20

(2)  DOS 窓から make コマンドを用いる
     対象：OAKS32ボード
     方式：DOS窓からmakeを使って構築
           カーネルをライブラリ化する方法としない方法の両方に対応
     動作確認ツール：
			NC308WA V.5.42 Release 00 無償評価版
            GNU make (version 3.80 で動作確認済)
            Perl (動作確認は Active Perl v5.6.1, 5.12.2 で行った)

ただし，いずれの場合も NC308WA のインストール先には注意が必要である．
最近の版では規定値として C:\Program Files 以下にインストールされるが，
TM 及び make はパス文字列中に空白が含まれる場合，正しく動作しない．
そのため，インストール先パスが空白を含まないようにする必要がある．

また，ソースの展開位置とツールのインストール先とが異なるドライブに
配置されている構成も，正常に動作しない場合があるため，推奨しない．

4.2  統合開発環境TMを用いた構築

m32c 用の TOPPERS/JSP を構築するには，ルネサスエレクトロニクス社製の
開発環境を使用する．そのため，まずツールをインストールしておく．
          統合開発環境 TM
          コンパイラ NC308WA

また，ターゲットプログラムの構築には，開発ホスト上で動作する，
コンフィギュレータ cfg/cfg.exe 及び M16Cターゲット向けユーティリティ
プログラム utils/m16c-renesas/m16cvec.exe  も用いる．
(m32cターゲットではm16coffset.exeは使用しない)
m16cvec.exe はコンパイル済みのものが用意されているが，
プログラムを変更したい場合は再構築する必要がある．


4.2.1 ツールの構築

cfg.exe の構築については user.txt などを参照のこと．
utils/m16c-renesas 上のツール m16cvec.exe を構築する場合，
MinGW (Minimalist GNU for Windows)を使用する．
(ちなみに，cfg.exe のビルドも MinGW で対応可能である）

通常は既にコンパイル済みのものが用意されているため，そちらを
利用すればよい．

MinGW (Minimalist GNU for Windows)
http://www.mingw.org/
http://sourceforge.net/projects/mingw/  (インストーラの入手先)


4.2.2 TM でプロジェクトを選択しビルドする．

(1) 事前確認

ビルド対象のソースコードがおかれているドライブと，コンパイラなどの
開発ツールがインストールされているドライブは同じドライブかどうか確認する.
異なる場合はビルドの確認が出来ていないため，非推奨の方法とする.

(2) プロジェクトのオープン

(2-1) Windows メニューから TM を起動する．
(2-2) TM が起動したら「Open Project」メニューを開く．
(2-3) tools/M32C-RENESAS ディレクトリ中の Jsp14sample1.tmk を選択する．
(2-4) 選択時，コンパイラの違いにより設定メニューが表示される場合がある．
      この環境は，NC308WA コンパイラの Version Version 5.42 Release 00 
      無償評価版にて評価を行っている．現在の環境にしたがって設定する．

(3) プリプロセッサの指定

ビルド過程でプリプロセッサを使用するため，開発環境がインストールされた
場所に応じて CPP という名前のマクロを変更する．


(4) 設定後，「リビルド」メニューを選択しビルドを行う

TMの設定としてソースファイルの依存性の設定を行っていないので，
構築時は「リビルド」の実行を推奨する．

　ビルドが終了すると，このディレクトリ中に Jsp14sample1.x30 および
Jsp14sample1.motが生成される．


4.3 DOS窓からmakeコマンドを用いた構築

GNU make を用いてm32c用の TOPPERS/JSPカーネルを構築する方法を示す．
この方法で対応しているボードは OAKS32 である．
コンパイラは NC308WA V.5.42 Release 00 無償評価版で動作を確認している.

構築にあたっては，コンフィギュレータ cfg.exe が cfg ディレクトリに，
4.2.1 で示した m16cvec.exe が utils/m16c-renesas ディレクトリに，
それぞれ存在していることが前提となる．
また，NC308WA, KD3083 はあらかじめインストールしておくことが必要である．

4.3.1 開発ツールの入手

ツールは以下のサイトから入手可能．

GNU Make 
http://www.mingw.org/

Active Perl
http://www.activestate.com/

4.3.2 サンプルプログラムの構築

 サンプルプログラムの構築方法は基本的に doc/user.txt の 「7.4 サンプルプ
ログラムの構築」で示された方法に準拠している．ただし，コンフィギュレーション
スクリプト等の perl で書かれたスクリプトはそのまま Windows の DOS窓
（Windows XP等では「コマンドスクリプト」）の上では使用することができない．
そのため，utils/m16c-renesas ディレクトリに用意された専用の Perl 
スクリプトを使用する．

4.3.3 コンフィギュレーションスクリプトの実行

   > mkdir foo
   > cd foo
   > perl ..\utils\m16c-renesas\configure.m16c -C m32c -S oaks32 -T renesas -D ..

-D オプションはディレクトリの位置により適当に修正する.
例は foo ディレクトリが JSPカーネルのトップディレクトリの下にある場合の例です.

この処理により，カレントディレクトリには以下のファイルが生成される
	・Makefile
	・サンプルプログラム用のコンフィギュレーションファイル（sample1.cfg）
	・サンプルプログラム本体（sample1.hおよびsample1.c）
ここでMakefileの修正が必要ならば，修正を行うのは他のターゲットの場合と同じである．

4.3.4 Makefile の修正

(A) メモリアドレスの設定

RAMEND は割込みスタックポインタの初期値，RAM_START_ADR はSFRを除いた
RAMの先頭番地，ROM_START_ADR は ROMの先頭番地をそれぞれ示す.

(B) ツールのインストールディレクトリ

NC308WA コンパイラツールのインストールされているディレクトリを
TOOLDIR に設定する.

(C) KD3083を使用するか
使用する場合はKD3083の値を1に，使用しない場合は0に設定する

(D) ライブラリアン LB308を使うかどうか

エントリー版コンパイラなど，ライブラリアンを持たない開発環境を用い，
カーネルライブラリの構築を行なわない場合は
USE_LB308 = TRUE
の行をコメントアウトする

(E) JSPカーネルソースのトップディレクトリの位置

通常は configure スクリプトで設定するが，JSPカーネルソース
ディレクトリとビルド作業を行うディレクトリとの位置関係が変化する場合は
SRCDIR の値を変更する.

(F) ターゲットファイルの定義

ロードされる実行プログラムの形式を指定する．IEEE-695形式のときは
$(OBJNAME).x30，モトローラ S形式の時は $(OBJNAME).mot を指定する．

(G) その他

　以下の項目については，doc/user.txt の内容に準拠しているので
そちらを参照のこと.
	・カーネルライブラリのディレクトリ名の定義
	・共通コンパイルオプションの定義
	・アプリケーションプログラムに関する定義
	・オブジェクトファイル名の定義
	・カーネルのコンフィギュレーションファイルの生成

4.3.5 依存関係ファイルの生成およびサンプルの実行プログラム作成

依存関係ファイル Makefile.depend および実行プログラム jsp.x30 および jsp.mot を
作成するには次のように実行する．MinGW の make を利用する場合，make の代わりに
mingw32-make を実行する必要があるかもしれない．

   > make depend
   > make

これで実行プログラム(jsp.x30,jsp.mot)がカレントディレクトリに生成される.

4.4 実行プログラムの転送

ボード上で実行を確認するための方法としては2通りの方法がある．

a. MOTファイルをFlashSta プログラムを用いて，ボード上のフラッシュROMに書き込む
b. デバッガKD3083を用いてロード，実行する
	OAKS32 には，デバッガ KD3083 が添付されている．このデバッガは
	フラッシュROM上のモニタプログラムと UART1 を用いて PC と通信を行う
	ことで，デバック機能を実現する．
	本カーネルはKD3083を使用してカーネルのロード，実行を行うことが出来る．
	使用に当たっては一部制限事項がある．詳細についてはKD3083のマニュアルを
	参照のこと．

4.4.1 FlashStaを用いてフラッシュROMに書き込む方法

・開発用のパソコンとOAKS32ボードとを，RS-232Cケーブルを使って接続する．
  OAKS32ボードのUART1ポートに接続する．
・CNVSSピンをジャンパーピンを使ってショートさせる．
・電源を接続し，電源スイッチをオンにする．

・FlashStaを起動する．
・Select Programメニューにてポートを選択して「OK」ボタンを押す．
・ID Checkメニューが表示されたら「Refer..」ボタンを押し，MOTファイルを選択する．
・Select Programに戻ったら，「OK」ボタンを押下しFlash Startメニューを表示させる．

・「Erase」ボタンを押し，フラッシュROMをクリアする．
・「Program..」ボタンを押しプログラムの書き込みを行う．
・書き込みが終了したら，「Exit」ボタンを押下しFlashStaを終了させる．
・ボードの電源を切り，CNVSSピンからジャンパーピンをはずす．

4.4.2 KD3083を使用してロード，実行する方法

・この方法を実行する場合は，あらかじめKD3083 用のモニタプログラムが
内臓 ROM に書き込まれているかどうか確認する. 書き込まれていない場合は
モニタプログラムを上記4.2.3の FlashSta を使用して書き込む必要がある.

・開発用のパソコンとOAKS32ボードとを，RS-232Cケーブルを使って接続する．
  OAKS32ボードはUART1ポートに接続する．
・電源を接続し，電源スイッチをオンにする．

・KD3083を起動する．
・Init画面で接続したPC側のポートと通信速度を設定し，「OK」を押す．
・メニュー「File→Download→Load Module」を選択し，.x30ファイルを選択する．
  すると，ロードモジュールがCPUボードに転送される．
  あとは「Go」ボタンを押せば実行が開始される．

4.4.3 sample1の実行に必要なPC側のシリアル設定

パソコン上で端末エミュレータソフトウェアを実行する．

通信設定は以下の通り．
	ボーレート： 38400bps
	データ長：8ビット
	パリティ：なし
	ストップビット：1ビット
	フロー制御：Xon/Xoff

5.  ファイル構成

5.1  ディレクトリ・ファイル構成

(1)   config/m32c-renesas

      api.h            ライブラリ化しない時に使用する，API定義
      cpu_config.c     M32Cプロセッサ依存部の C 関数
      cpu_config.h     M32Cプロセッサ依存部の構成定義
      cpu_context.h    M32Cプロセッサ依存部のコンテキスト操作
      cpu_defs.h       M32Cプロセッサ依存部のアプリケーション用定義
      cpu_insn.h       M32Cプロセッサのアセンブリ inline 関数
      cpu_rename.def   カーネルの内部識別名のリネームとその解除の定義リスト
      cpu_rename.h     カーネルの内部識別名のリネームの定義
      cpu_support.a30  M32Cプロセッサのアセンブリ関数
      cpu_unrename.h   カーネルの内部識別名のリネーム解除の定義
      makeoffset.c     offset.inc 生成サポート関数
      offset.inc       TCBメンバへのオフセット定義ファイル
      start.a30        スタートアップモジュール
      tool_config.h    M32Cプロセッサの開発環境依存モジュール定義
      tool_defs.h      M32Cプロセッサの開発環境依存定義

(2)   config/m32c-renesas/oak32/

      hw_serial.cfg    SCI のコンフィギュレーションファイル
      hw_serial.h      SCI のヘッダファイル
      hw_timer.h       OAKS32用タイマ操作ルーチン
      Makefile.kernel  カーネルのファイル構成の定義(M32C用)
                       makeコマンドを用いたm32c用TOPPERS/JSPカーネル構築で使用する
      oaks32.h         プロセッサの定義
      sfr_uart.c       OAKS32用SIOドライバのC関数
      sfr_uart.h       OAKS32用SIOドライバのヘッダファイル
      sys_config.c     OAKS32ボード依存部の C 関数
      sys_config.h     OAKS32ボード依存部の構成定義
      sys_defs.h       OAKS32ボード依存部のアプリケーション用定義
      sys_rename.def   カーネルの内部識別名のリネームとその解除の定義リスト
      sys_rename.h     カーネルの内部識別名のリネームの定義
      sys_unrename.h   カーネルの内部識別名のリネーム解除の定義

(3)   tools/M32C-RENESAS/
                       統合開発環境TMを用いてTOPPERS/JSPを構築するための
                       プロジェクトファイルが置かれたディレクトリ
      Jsp14sample1.tmi,Jsp14sample.tmk
                       TMを用いてOAKS32用のTOPPERS/JSPを構築するためのプロジェクトファイル
      sample1.cfg      OAKS32用のTOPPERS/JSPを構築するためのコンフィギュレーションファイル

(4)   sample/

      Makefile.m32c-oaks32	GNU make コマンドを使用してTOPPERS/JSPカーネルを構築
                            するための Makefile